<!DOCTYPE html>
    <html>
    <head><base target="_blank"><link rel="stylesheet" type="text/css" href="https://app.wandb.ai/normalize.css" />
        <meta charset="UTF-8">
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;700&display=swap');
            
            body {
                font-family: 'Arial', sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f9f9f9;
            }
            
            .container {
                display: flex;
                flex-direction: column;
                align-items: center;
                max-width: 900px;
                margin: 0 auto;
                background-color: white;
                box-shadow: 0 2px 10px rgba(0,0,0,0.05);
                border-radius: 8px;
                padding: 25px;
            }
            
            .visualization {
                display: flex;
                flex-direction: column;
                margin: 20px;
                position: relative;
                width: 100%;
            }
            
            .row {
                display: flex;
                justify-content: space-around;
                margin: 10px 0;
                position: relative;
                width: 100%;
            }
            
            .input-row, .output-row {
                display: flex;
                justify-content: space-around;
                width: 100%;
            }
            
            .cell {
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 1px solid #ddd;
                background-color: #f8f8f8;
                margin: 0 5px;
                position: relative;
                font-size: 18px;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .input-cell {
                font-family: 'Arial', sans-serif;
            }
            
            .output-cell {
                font-family: 'Noto Sans Devanagari', sans-serif;
                font-size: 20px;
            }
            
            .connection-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 0;
            }
            
            .connection {
                position: absolute;
                background-color: rgba(0, 128, 0, 0.5);
                height: 2px;
                transform-origin: 0 0;
                pointer-events: none;
                transition: opacity 0.2s, height 0.2s;
            }
            
            .model-type {
                font-weight: bold;
                font-size: 20px;
                margin: 10px;
                background-color: #eee;
                padding: 10px;
                border-radius: 5px;
            }
            
            .highlighted {
                background-color: #ffeb3b;
                box-shadow: 0 0 5px rgba(0,0,0,0.3);
                z-index: 10;
            }
            
            .title {
                font-weight: bold;
                font-size: 24px;
                margin: 20px;
            }
            
            .instructions {
                margin: 10px;
                font-style: italic;
                color: #666;
                text-align: center;
                max-width: 600px;
            }
            
            .controls {
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 15px 0;
            }
            
            .slider-container {
                display: flex;
                align-items: center;
                margin-right: 20px;
            }
            
            .slider-label {
                margin-right: 10px;
                font-weight: bold;
            }
            
            #threshold-slider {
                width: 150px;
            }
            
            #threshold-value {
                margin-left: 10px;
                min-width: 40px;
                text-align: center;
            }
            
            /* Prediction tooltip */
            .prediction-tooltip {
                position: absolute;
                background-color: rgba(255, 255, 255, 0.95);
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                width: 180px;
                top: 45px;
                left: 50%;
                transform: translateX(-50%);
                font-family: 'Noto Sans Devanagari', sans-serif;
                z-index: 1000;
                pointer-events: none;
                transition: opacity 0.3s ease;
                opacity: 0;
            }
            
            .prediction-tooltip.visible {
                opacity: 1;
            }
            
            .prediction-tooltip::before {
                content: '';
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                border-width: 0 8px 8px 8px;
                border-style: solid;
                border-color: transparent transparent #ddd transparent;
            }
            
            .prediction-tooltip h4 {
                margin: 0 0 8px 0;
                text-align: center;
                font-size: 14px;
                color: #444;
            }
            
            .prediction-item {
                display: flex;
                justify-content: space-between;
                margin: 4px 0;
                padding: 3px;
                border-radius: 3px;
            }
            
            .prediction-item:hover {
                background-color: #f5f5f5;
            }
            
            .prediction-char {
                font-size: 18px;
                font-weight: bold;
            }
            
            .prediction-prob {
                font-size: 14px;
                color: #666;
            }
            
            .prediction-prob-bar {
                height: 6px;
                background-color: #4caf50;
                margin-top: 2px;
                border-radius: 3px;
            }
            
            /* Floating prediction display */
            #floating-prediction {
                position: absolute;
                background-color: rgba(255, 255, 255, 0.95);
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                width: 180px;
                z-index: 1000;
                pointer-events: none;
                font-family: 'Noto Sans Devanagari', sans-serif;
                display: none;
            }
            
            .output-row {
                position: relative;
            }
            
            .prediction-slider {
                position: absolute;
                height: 5px;
                background-color: rgba(64, 158, 255, 0.6);
                bottom: -10px;
                transition: left 0.1s ease, width 0.1s ease;
                border-radius: 3px;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="title">Transliteration Attention Connectivity</div>
            <div class="instructions">
                Hover over any character to see its connections. 
                The green lines show the attention weights: stronger connections have darker green lines.
                Move your mouse along the output characters to see top predictions in real-time.
                Use the threshold slider to filter the connections by strength.
            </div>
            
            <div class="controls">
                <div class="slider-container">
                    <span class="slider-label">Threshold:</span>
                    <input type="range" id="threshold-slider" min="0" max="1" step="0.05" value="0.1">
                    <span id="threshold-value">0.1</span>
                </div>
            </div>
            
            <div class="model-type">Sequence-to-Sequence with Attention [ LSTM ]</div>
            <div class="visualization">
                <div class="row input-row">
    <div class="cell input-cell" data-index="0" onmouseover="highlightInputConnections(0)" onmouseout="resetHighlights()">t</div><div class="cell input-cell" data-index="1" onmouseover="highlightInputConnections(1)" onmouseout="resetHighlights()">a</div><div class="cell input-cell" data-index="2" onmouseover="highlightInputConnections(2)" onmouseout="resetHighlights()">k</div><div class="cell input-cell" data-index="3" onmouseover="highlightInputConnections(3)" onmouseout="resetHighlights()">r</div><div class="cell input-cell" data-index="4" onmouseover="highlightInputConnections(4)" onmouseout="resetHighlights()">a</div><div class="cell input-cell" data-index="5" onmouseover="highlightInputConnections(5)" onmouseout="resetHighlights()">n</div><div class="cell input-cell" data-index="6" onmouseover="highlightInputConnections(6)" onmouseout="resetHighlights()">e</div>
                </div>
                <div class="connection-container">
    <div class="connection" data-from-input="0" data-to-output="0" data-weight="0.1874" style="opacity: 0;"></div><div class="connection" data-from-input="1" data-to-output="0" data-weight="0.7989" style="opacity: 0;"></div><div class="connection" data-from-input="2" data-to-output="1" data-weight="0.9432" style="opacity: 0;"></div><div class="connection" data-from-input="3" data-to-output="2" data-weight="0.9123" style="opacity: 0;"></div><div class="connection" data-from-input="4" data-to-output="3" data-weight="0.3113" style="opacity: 0;"></div><div class="connection" data-from-input="5" data-to-output="3" data-weight="0.4633" style="opacity: 0;"></div><div class="connection" data-from-input="6" data-to-output="3" data-weight="0.1867" style="opacity: 0;"></div><div class="connection" data-from-input="6" data-to-output="4" data-weight="0.7848" style="opacity: 0;"></div>
                </div>
                <div class="row output-row">
    
                <div id="floating-prediction"></div>
                <div class="prediction-slider"></div>
    
        <div class="cell output-cell" 
             data-index="0" 
             data-pred0-token='त' data-pred0-prob='0.66' data-pred1-token='ट' data-pred1-prob='0.34' data-pred2-token='ठ' data-pred2-prob='0.00'
             onmouseover="highlightOutputConnections(0);" 
             onmouseout="resetHighlights();">
            त
        </div>
        
        <div class="cell output-cell" 
             data-index="1" 
             data-pred0-token='क' data-pred0-prob='0.99' data-pred1-token='ा' data-pred1-prob='0.00' data-pred2-token='ख' data-pred2-prob='0.00'
             onmouseover="highlightOutputConnections(1);" 
             onmouseout="resetHighlights();">
            क
        </div>
        
        <div class="cell output-cell" 
             data-index="2" 
             data-pred0-token='र' data-pred0-prob='0.70' data-pred1-token='क' data-pred1-prob='0.14' data-pred2-token='्' data-pred2-prob='0.11'
             onmouseover="highlightOutputConnections(2);" 
             onmouseout="resetHighlights();">
            र
        </div>
        
        <div class="cell output-cell" 
             data-index="3" 
             data-pred0-token='न' data-pred0-prob='0.41' data-pred1-token='ा' data-pred1-prob='0.21' data-pred2-token='ण' data-pred2-prob='0.11'
             onmouseover="highlightOutputConnections(3);" 
             onmouseout="resetHighlights();">
            न
        </div>
        
        <div class="cell output-cell" 
             data-index="4" 
             data-pred0-token='े' data-pred0-prob='0.90' data-pred1-token='न' data-pred1-prob='0.09' data-pred2-token='<eos>' data-pred2-prob='0.00'
             onmouseover="highlightOutputConnections(4);" 
             onmouseout="resetHighlights();">
            े
        </div>
        
                </div>
            </div>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', function() {
                positionConnections();
                window.addEventListener('resize', positionConnections);
                
                const thresholdSlider = document.getElementById('threshold-slider');
                const thresholdValue = document.getElementById('threshold-value');
                
                thresholdSlider.addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    thresholdValue.textContent = value.toFixed(2);
                    updateConnectionVisibility(value);
                });
                
                // Set up smooth prediction tooltip
                setupSmoothPredictions();
            });
            
            function setupSmoothPredictions() {
                const outputRow = document.querySelector('.output-row');
                const floatingPrediction = document.getElementById('floating-prediction');
                const predictionSlider = document.querySelector('.prediction-slider');
                
                // Initialize prediction HTML structure
                floatingPrediction.innerHTML = `
                    <h4>Top Predictions</h4>
                    <div class="prediction-item">
                        <div class="prediction-char">—</div>
                        <div class="prediction-prob">
                            <div>0.00</div>
                            <div class="prediction-prob-bar" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="prediction-item">
                        <div class="prediction-char">—</div>
                        <div class="prediction-prob">
                            <div>0.00</div>
                            <div class="prediction-prob-bar" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="prediction-item">
                        <div class="prediction-char">—</div>
                        <div class="prediction-prob">
                            <div>0.00</div>
                            <div class="prediction-prob-bar" style="width: 0%;"></div>
                        </div>
                    </div>
                `;
                
                // Add mousemove event to the output row
                outputRow.addEventListener('mousemove', function(e) {
                    const rowRect = outputRow.getBoundingClientRect();
                    const cells = outputRow.querySelectorAll('.output-cell');
                    
                    if (cells.length === 0) return;
                    
                    // Show the floating prediction
                    floatingPrediction.style.display = 'block';
                    
                    // Calculate relative position in the row
                    const relX = e.clientX - rowRect.left;
                    
                    // Position the floating tooltip
                    floatingPrediction.style.left = (e.clientX - floatingPrediction.offsetWidth / 2) + 'px';
                    floatingPrediction.style.top = (rowRect.bottom + 10) + 'px';
                    
                    // Find the nearest cell
                    let nearestIndex = 0;
                    let minDistance = Infinity;
                    
                    cells.forEach((cell, index) => {
                        const cellRect = cell.getBoundingClientRect();
                        const cellCenter = cellRect.left + cellRect.width / 2;
                        const distance = Math.abs(e.clientX - cellCenter);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestIndex = index;
                        }
                    });
                    
                    // Update the prediction slider position
                    const nearestCell = cells[nearestIndex];
                    const cellRect = nearestCell.getBoundingClientRect();
                    
                    predictionSlider.style.display = 'block';
                    predictionSlider.style.left = (cellRect.left - rowRect.left) + 'px';
                    predictionSlider.style.width = cellRect.width + 'px';
                    
                    // Update the prediction content
                    updatePredictionContent(nearestCell);
                });
                
                // Hide prediction when mouse leaves the row
                outputRow.addEventListener('mouseleave', function() {
                    floatingPrediction.style.display = 'none';
                    predictionSlider.style.display = 'none';
                });
            }
            
            function updatePredictionContent(cell) {
                const floatingPrediction = document.getElementById('floating-prediction');
                const predictionItems = floatingPrediction.querySelectorAll('.prediction-item');
                
                // Get prediction data from cell attributes
                for (let i = 0; i < 3; i++) {
                    const token = cell.getAttribute(`data-pred${i}-token`);
                    const prob = parseFloat(cell.getAttribute(`data-pred${i}-prob`));
                    
                    if (token && !isNaN(prob)) {
                        const charElem = predictionItems[i].querySelector('.prediction-char');
                        const probElem = predictionItems[i].querySelector('.prediction-prob div');
                        const barElem = predictionItems[i].querySelector('.prediction-prob-bar');
                        
                        charElem.textContent = token;
                        probElem.textContent = prob.toFixed(2);
                        barElem.style.width = (prob * 100) + '%';
                        
                        // Highlight if it's the actual token
                        const isActual = token === cell.textContent.trim();
                        predictionItems[i].style.backgroundColor = isActual ? '#e6f7e6' : '';
                    }
                }
            }

            function updateConnectionVisibility(threshold) {
                const connections = document.querySelectorAll('.connection');
                connections.forEach(conn => {
                    const weight = parseFloat(conn.getAttribute('data-weight'));
                    conn.style.display = weight >= threshold ? 'block' : 'none';
                });
            }

            function positionConnections() {
                const connections = document.querySelectorAll('.connection');
                const inputCells = document.querySelectorAll('.input-cell');
                const outputCells = document.querySelectorAll('.output-cell');
                const containerRect = document.querySelector('.connection-container').getBoundingClientRect();
                
                connections.forEach(conn => {
                    const fromIndex = parseInt(conn.getAttribute('data-from-input'));
                    const toIndex = parseInt(conn.getAttribute('data-to-output'));
                    const weight = parseFloat(conn.getAttribute('data-weight'));
                    
                    if (fromIndex < inputCells.length && toIndex < outputCells.length) {
                        const fromCell = inputCells[fromIndex];
                        const toCell = outputCells[toIndex];
                        
                        const fromRect = fromCell.getBoundingClientRect();
                        const toRect = toCell.getBoundingClientRect();
                        
                        const fromX = fromRect.left + fromRect.width/2 - containerRect.left;
                        const fromY = fromRect.top + fromRect.height - containerRect.top;
                        const toX = toRect.left + toRect.width/2 - containerRect.left;
                        const toY = toRect.top - containerRect.top;
                        
                        const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                        const angle = Math.atan2(toY - fromY, toX - fromX);
                        
                        conn.style.width = `${length}px`;
                        conn.style.left = `${fromX}px`;
                        conn.style.top = `${fromY}px`;
                        conn.style.transform = `rotate(${angle}rad)`;
                        
                        // Set opacity based on weight
                        conn.style.opacity = weight;
                        conn.style.backgroundColor = `rgba(0, 128, 0, ${weight})`;
                    }
                });
                
                // Apply initial threshold
                const thresholdSlider = document.getElementById('threshold-slider');
                if (thresholdSlider) {
                    updateConnectionVisibility(parseFloat(thresholdSlider.value));
                }
            }

            function highlightInputConnections(index) {
                const connections = document.querySelectorAll(`.connection[data-from-input="${index}"]`);
                const cell = document.querySelector(`.input-cell[data-index="${index}"]`);
                
                cell.classList.add('highlighted');
                
                connections.forEach(conn => {
                    const toIndex = conn.getAttribute('data-to-output');
                    document.querySelector(`.output-cell[data-index="${toIndex}"]`).classList.add('highlighted');
                    conn.style.height = '3px';
                    conn.style.zIndex = '5';
                });
            }

            function highlightOutputConnections(index) {
                const connections = document.querySelectorAll(`.connection[data-to-output="${index}"]`);
                const cell = document.querySelector(`.output-cell[data-index="${index}"]`);
                
                cell.classList.add('highlighted');
                
                connections.forEach(conn => {
                    const fromIndex = conn.getAttribute('data-from-input');
                    document.querySelector(`.input-cell[data-index="${fromIndex}"]`).classList.add('highlighted');
                    conn.style.height = '3px';
                    conn.style.zIndex = '5';
                });
            }

            function resetHighlights() {
                document.querySelectorAll('.highlighted').forEach(el => {
                    el.classList.remove('highlighted');
                });
                document.querySelectorAll('.connection').forEach(conn => {
                    conn.style.height = '2px';
                    conn.style.zIndex = '0';
                });
            }
        </script>
    </body>
    </html>